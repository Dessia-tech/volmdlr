<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>d3 and canvas</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<script type="text/javascript" src="{{volmdlr_path}}/d3/d3-v5.js"></script>

	<style type="text/css">

		body {
			font-family: 'Open Sans', sans-serif;

		}

		canvas {
			border:  1px dotted #ccc;

		}

		#text-explain {
			display: inline-block;
			font-size: 0.75em;
			margin-bottom: 1em;
		}

		.alert {
			color: tomato;
		}


/* new (in comparison to code w/o interactivty at:) ---- */
/* (http://blockbuilder.org/larsvers/d187337850d58a444082841c739985ca) */

		div#tooltip {
		  position: absolute;
			display: inline-block;
			padding: 10px;
			font-family: 'Open Sans' sans-serif;
			color: #000;
		  background-color: #fff;
			border: 1px solid #999;
			border-radius: 2px;
		  pointer-events: none;
			opacity: 0;
			z-index: 1;
		}

/* new ------------------------------------------------ */


	</style>

</head>
<body>

	<h3>Coloured grids</h3>
	<input type="text" id="text-input" value="5000">
	<div id="text-explain">...takes numbers between 1 and 10k</div>
	<div id="container"></div>

	<div id="tooltip">hello</div>	<!-- new  -->

	<script>

		var D3Data = {{ D3Data | safe }};
		var number_plot_data = D3Data.length
		var show_state = 1

		D3Data.forEach(function(dict_component, i){
			var number_states = dict_component.plot_data_states.length
		})

		var log = console.log.bind(console);
		var dir = console.dir.bind(console);
		var replace = function(string) { return string.replace(/[^a-z0-9]/gi,""); };


		// === Set up canvas === //

		var width = 750,
				height = 400;

		var data = [];
		var value = 5000;
		var colorScale;

		var coeff_size = 1
		// d3.select('#container').append("defs")
    //     .append("pattern")
    //     .attr("id","diagonal-stripe-1")
    //     .attr("width", 100)
    //     .attr("data-width-init", 100)
    //     .attr("height","1")
    //     .attr("patternUnits","userSpaceOnUse")
    //     .attr("patternTransform", "rotate(45)")
    //     .append("rect")
    //     .attr("id","rect-diagonal-stripe-1")
    //     .attr("width", 1/coeff_size)
    //     .attr("data-width-init", 1/coeff_size)
    //     .attr("height","100")
    //     .attr("transform","translate(0,0)")
    //     .attr("fill","blue");

		// ctx.fillStyle=ctx.createPattern(p_hatch,'repeat');

		var mainCanvas = d3.select('#container')
			.append('canvas')
			.classed('mainCanvas', true)
			.attr('width', width)
			.attr('height', height)
			.attr('overflow', true);
		//
		// var p_hatch = d3.select('#container')
		// 		.append('canvas')
		// 		.classed('p_hatch', true)
		// 		.attr('width', 200)
		// 		.attr('height', 200);
		var p_hatch = document.createElement("canvas");
		var max_size = 100
		var nb_hatch = 20
		p_hatch.width = max_size;
		p_hatch.height = max_size;
		var pctx = p_hatch.getContext("2d");

		// var pctx=p_hatch.node().getContext('2d');

		pctx.lineWidth = 0.5;
		pctx.lineCap = 'square';
		pctx.beginPath();
		var pos_x = - Math.pow(Math.pow(max_size,2)/2, 0.5)
		var pos_y = Math.pow(Math.pow(max_size,2)/2, 0.5)
		for (var i = 0; i <= 2*nb_hatch; i++) {
			pos_x = pos_x + max_size/nb_hatch
			pos_y = pos_y - max_size/nb_hatch
			pctx.moveTo(pos_x, pos_y);
			pctx.lineTo(pos_x + max_size, pos_y + max_size);
		}
		pctx.stroke();

// new -----------------------------------------------------

		var hiddenCanvas = d3.select('#container')
			.append('canvas')
			.classed('hiddenCanvas', true)
			.attr('width', width)
			.attr('height', height)
			.attr('overflow', true);

		var colourToNode = {}; // map to track the colour of nodes

		// function to create new colours for the picking

		var nextCol = 1;

		function genColor(){
			var ret = [];
			// via http://stackoverflow.com/a/15804183
			if(nextCol < 16777215){
			  ret.push(nextCol & 0xff); // R
			  ret.push((nextCol & 0xff00) >> 8); // G
			  ret.push((nextCol & 0xff0000) >> 16); // B

			  nextCol += 1;
			}
			var col = "rgb(" + ret.join(',') + ")";
			return col;
		}

// new -----------------------------------------------------


		// === Load and prepare the data === //

		var data = [];
		d3.range(2).forEach(function(el) {
		  data.push({ value: el + 1});
		});

		// === Bind data to custom elements === //

		var customBase = document.createElement('custom');
		var custom = d3.select(customBase); // this is our svg replacement

		// settings for a grid with 40 cells in a row and 2x5 cells in a group
		var groupSpacing = 4;
		var cellSpacing = 2;
		var cellSize = 200;


		// === First call === //

		databind(D3Data, show_state); // ...then update the databind function

		var t = d3.timer(function(elapsed) {
			draw(mainCanvas, false, 0, 0, 1); // <--- new insert arguments
			draw(hiddenCanvas, true, 0, 0, 1);
			if (elapsed > 300) t.stop();
		}); // start a timer that runs the draw function for 300 ms (this needs to be higher than the transition in the databind function)


		// === Bind and draw functions === //
		var plot_data_states = D3Data

		function databind(data, show_state) {

			data.forEach(function(dict_component, i){

				var stroke_width = dict_component.plot_data_states[show_state-1].stroke_width
				var color_line = dict_component.plot_data_states[show_state-1].color_line
				var hatching = dict_component.plot_data_states[show_state-1].hatching
				var color_surface = dict_component.plot_data_states[show_state-1].color_surface
				if (color_surface != null) {
					var color = color_surface.color
				} else {
					var color = null
				}

				var join = custom.selectAll('custom.plot_data_'+i.toString())
					.data(dict_component.plot_data_primitives);
				var enterSel = join.enter()
					.append('custom')
					.attr('class', 'plot_data_'+i.toString())
		      .attr('type', function(d, i) {return d.type;})
		      .attr('data', function(d, i) {return d.data;})
					.attr('r', function(d, i) {return d.r;})
					.attr('cx', function(d, i) {return d.cx;})
					.attr('cy', function(d, i) {return d.cy;})
					.attr('angle1', function(d, i) {return d.angle1;})
					.attr('angle2', function(d, i) {return d.angle2;})
					.attr('hatching', hatching)
					.attr('fill', color)
					.attr('stroke_width', stroke_width)
					.attr('color_line', color_line)
					.attr('width', 0)
					.attr('height', 0);
				join
					.merge(enterSel)
					.transition()
					.attr('width', cellSize)
					.attr('height', cellSize)
					.attr('fillStyleHidden', function(d) {
						if (!d.hiddenCol) {
							d.hiddenCol = genColor();
							colourToNode[d.hiddenCol] = i;
						} // here we (1) add a unique colour as property to each element and (2) map the colour to the node in the colourToNode-dictionary
						return d.hiddenCol;
					});
				var exitSel = join.exit()
					.transition()
					.attr('width', 0)
					.attr('height', 0)
					.remove();
				console.log(custom)
			})
		}


		// === Draw canvas === //

		function draw(canvas, show_state, hidden, mvx, mvy, scale, on_mouse, on_clic) { // <---- new arguments

			var color_surface_on_mouse = 'blue'
			var color_surface_on_clic = 'green'

			// build context
			var context = canvas.node().getContext('2d');

			// clear canvas
			context.clearRect(0, 0, width, height);

			// draw each individual custom element with their properties

			for (var k = 0; k < number_plot_data; k++) {
				var elements = custom.selectAll('custom.plot_data_'+k.toString()) // this is the same as the join variable, but used here to draw
				var states = custom.selectAll('custom.plot_data_'+k.toString()+'_state')

				context.beginPath();
				if (hidden) {
					context.fillStyle = elements.attr('fillStyleHidden')
				} else {
					var hatching = elements.attr('hatching')
					var color = elements.attr('fill')
					if (hatching != null) {
						context.fillStyle = context.createPattern(p_hatch,'repeat');
					} else if (color != null) {
						context.fillStyle = color
					}
					if (on_mouse != null && k == on_mouse) {
						context.fillStyle = color_surface_on_mouse
					}
					if (on_clic != null && k == on_clic) {
						context.fillStyle = color_surface_on_clic
					}

					context.strokeStyle = elements.attr('color_line');
					context.lineWidth = elements.attr('stroke_width');
				}
				elements.each(function(d,i) { // for each virtual/custom element...

					var node = d3.select(this);
					if (node.attr('type') === 'line'){
						var data = node.attr('data')
						if (i = 0) {
							context.moveTo(scale*(1000*d.data[0]+ mvx), scale*(1000*d.data[1]+ mvy));
						}
						context.lineTo(scale*(1000*d.data[2]+ mvx), scale*(1000*d.data[3]+ mvy));
					} else if (node.attr('type') === 'arc') {
						var ptsa = []
						for (var l = 0; l < d.data.length; l++) {
							ptsa.push(scale*(1000*d.data[l]['x']+ mvx))
							ptsa.push(scale*(1000*d.data[l]['y']+ mvy))
						}
						var tension = 0.4
						var isClosed = false
						var numOfSegments = 16
    				drawLines(context, getCurvePoints(ptsa, tension, isClosed, numOfSegments));

					} else if (node.attr('type') === 'circle') {
						context.arc(scale*(1000*node.attr('cx')+ mvx), scale*(1000*node.attr('cy')+ mvy), scale*1000*node.attr('r'), 0, 2*Math.PI);
					}



					// console.log(node, node.attr('type'))
					// context.fillStyle = context.createPattern(p_hatch,'repeat');
					// // context.fillStyle = hidden ? node.attr('fillStyleHidden') : node.attr('fillStyle'); // <--- new: node colour depends on the canvas we draw
					// // log(context.fillStyle)
					// context.fillRect(scale*(Math.floor(node.attr('x')) + mvx), scale*(Math.floor(node.attr('y')) + mvy), scale*Math.floor(node.attr('width')), scale*Math.floor(node.attr('height')))
					// context.strokeRect(scale*(Math.floor(node.attr('x')) + mvx), scale*(Math.floor(node.attr('y')) + mvy), scale*Math.floor(node.attr('width')), scale*Math.floor(node.attr('height')))
					// context.fill();
					// context.strokeStyle = 'green'
					// context.lineWidth = 2;

				});

				context.closePath();
				context.fill();
				context.stroke();
			}

		}


		// === Listeners/handlers === //


		d3.select('#text-input').on('keydown', function() {

			if (d3.event.keyCode === 13) {

				d3.select('#alert').html('');

				if (+this.value < 1 || +this.value > 10000) {

					d3.select('#text-explain').classed('alert', true);

					return;

				} else {

					d3.select('#text-explain').classed('alert', false);

					data = [];

					d3.range(+this.value).forEach(function(el) {

						data.push({ value: el });

					});

			    databind(data);

					var t = d3.timer(function(elapsed) {
						draw(mainCanvas, false); // <--- new insert arguments
						if (elapsed > 300) t.stop();
					}); // start a timer that runs the draw function for 300 ms (this needs to be higher than the transition in the databind function)

				} // value test

		  } // keyCode 13 === return

		}); // text input listener/handler




// new -----------------------------------------------------
		let isDrawing = false
		let isDrawing_onmouse = true
		let mouse1X = 0
		let mouse1Y = 0
		let mouse2X = 0
		let mouse2Y = 0
		let mouse3X = 0
		let mouse3Y = 0
		let last_mouse1X = 0
		let last_mouse1Y = 0
		let scale = 1

		d3.select('.mainCanvas').on('mousedown', function() {
			mouse1X = d3.event.layerX || d3.event.offsetX;
			mouse1Y = d3.event.layerY || d3.event.offsetY;
			isDrawing = true
		});

		d3.select('.mainCanvas').on('click', function() {
			console.log('clic')
			if (isDrawing_onmouse == true) {
				var mouseX = d3.event.layerX || d3.event.offsetX;
				var mouseY = d3.event.layerY || d3.event.offsetY;

				// get the toolbox for the hidden canvas
				var hiddenCtx = hiddenCanvas.node().getContext('2d');

				// Now to pick the colours from where our mouse is then stringify it in a way our map-object can read it
				var col = hiddenCtx.getImageData(mouseX, mouseY, 1, 1).data;
				var colKey = 'rgb(' + col[0] + ',' + col[1] + ',' + col[2] + ')';

				// get the data from our map !
				var nodeData = colourToNode[colKey];
				console.log(nodeData)
				draw(mainCanvas, show_state, false, last_mouse1X, last_mouse1Y, scale, null, nodeData);
			}
		});

		d3.select('.mainCanvas').on('mousemove', function() {
			if (isDrawing === true) {
				isDrawing_onmouse = false
				mouse2X = d3.event.layerX || d3.event.offsetX;
				mouse2Y = d3.event.layerY || d3.event.offsetY;
				draw(mainCanvas, show_state, false, last_mouse1X + mouse2X/scale - mouse1X/scale, last_mouse1Y + mouse2Y/scale - mouse1Y/scale, scale, null, null);
				draw(hiddenCanvas, show_state, true, last_mouse1X + mouse2X/scale - mouse1X/scale, last_mouse1Y + mouse2Y/scale - mouse1Y/scale, scale, null, null);
			} else {
				var mouseX = d3.event.layerX || d3.event.offsetX;
				var mouseY = d3.event.layerY || d3.event.offsetY;

				// get the toolbox for the hidden canvas
				var hiddenCtx = hiddenCanvas.node().getContext('2d');

				// Now to pick the colours from where our mouse is then stringify it in a way our map-object can read it
				var col = hiddenCtx.getImageData(mouseX, mouseY, 1, 1).data;
				var colKey = 'rgb(' + col[0] + ',' + col[1] + ',' + col[2] + ')';

				// get the data from our map !
				var nodeData = colourToNode[colKey];
				console.log(nodeData)
				draw(mainCanvas, show_state, false, last_mouse1X, last_mouse1Y, scale, nodeData, null);
			}
		});

		d3.select('.mainCanvas').on('mouseup', function() {
			last_mouse1X = last_mouse1X + mouse2X/scale - mouse1X/scale
			last_mouse1Y = last_mouse1Y + mouse2Y/scale - mouse1Y/scale
			isDrawing = false
			isDrawing_onmouse = true
		});

		d3.select('.mainCanvas').on('wheel', function() {
			scale = scale + d3.event.wheelDelta/100
			mouse3X = d3.event.layerX || d3.event.offsetX;
			mouse3Y = d3.event.layerY || d3.event.offsetY;
			last_mouse1X = last_mouse1X - (mouse3X/(scale - d3.event.wheelDelta/100) - mouse3X/scale)
			last_mouse1Y = last_mouse1Y - (mouse3Y/(scale - d3.event.wheelDelta/100) - mouse3Y/scale)
			draw(mainCanvas, show_state, false, last_mouse1X, last_mouse1Y, scale, null, null);
			draw(hiddenCanvas, show_state, true, last_mouse1X, last_mouse1Y, scale, null, null);
		});

		// d3.select('.mainCanvas').on('mousemove', function() {
		//
		// 	console.log(isDrawing)
		// 	if (!isDrawing) {
		// 		var mouseX = d3.event.layerX || d3.event.offsetX;
		// 		var mouseY = d3.event.layerY || d3.event.offsetY;
		// 		console.log(mouseX, mouseY)
		//
		//
		// 		// get the toolbox for the hidden canvas
		// 		var hiddenCtx = hiddenCanvas.node().getContext('2d');
		//
		// 		// Now to pick the colours from where our mouse is then stringify it in a way our map-object can read it
		// 		var col = hiddenCtx.getImageData(mouseX, mouseY, 1, 1).data;
		// 		var colKey = 'rgb(' + col[0] + ',' + col[1] + ',' + col[2] + ')';
		//
		// 		// get the data from our map !
		// 		var nodeData = colourToNode[colKey];
		// 		log(nodeData);
		// 	}
		// 	// draw the hiddenCanvas
		//
		//
		// 	// get mousePositions from the main canvas
		// 	// var mouseX = d3.event.layerX || d3.event.offsetX;
		// 	// var mouseY = d3.event.layerY || d3.event.offsetY;
		// 	// console.log(mouseX, mouseY)
		// 	//
		// 	//
		// 	// // get the toolbox for the hidden canvas
		// 	// var hiddenCtx = hiddenCanvas.node().getContext('2d');
		// 	//
		// 	// // Now to pick the colours from where our mouse is then stringify it in a way our map-object can read it
		// 	// var col = hiddenCtx.getImageData(mouseX, mouseY, 1, 1).data;
		// 	// var colKey = 'rgb(' + col[0] + ',' + col[1] + ',' + col[2] + ')';
		// 	//
		// 	// // get the data from our map !
		// 	// var nodeData = colourToNode[colKey];
		// 	// log(nodeData);
		// 	//
		// 	//
		// 	// if (nodeData) {
		// 	//
		// 	// 	// Show the tooltip only when there is nodeData found by the mouse
		// 	//
		// 	// 	d3.select('#tooltip')
		// 	// 		.style('opacity', 0.8)
		// 	// 		.style('top', d3.event.pageY + 5 + 'px')
		// 	// 		.style('left', d3.event.pageX + 5 + 'px')
		// 	// 		.html(nodeData.value);
		// 	//
		// 	// } else {
		// 	//
		// 	// 	// Hide the tooltip when there our mouse doesn't find nodeData
		// 	//
		// 	// 	d3.select('#tooltip')
		// 	// 		.style('opacity', 0);
		// 	//
		// 	// }
		//
		// }); // canvas listener/handler


// new -----------------------------------------------------
function drawLines(ctx, pts) {
    // ctx.moveTo(pts[0], pts[1]);
    for(i=2;i<pts.length-1;i+=2) ctx.lineTo(pts[i], pts[i+1]);
}

function getCurvePoints(pts, tension, isClosed, numOfSegments) {

    // use input value if provided, or use a default value
    tension = (typeof tension != 'undefined') ? tension : 0.5;
    isClosed = isClosed ? isClosed : false;
    numOfSegments = numOfSegments ? numOfSegments : 16;

    var _pts = [], res = [],    // clone array
        x, y,           // our x,y coords
        t1x, t2x, t1y, t2y, // tension vectors
        c1, c2, c3, c4,     // cardinal points
        st, t, i;       // steps based on num. of segments

    // clone array so we don't change the original
    //
    _pts = pts.slice(0);

    // The algorithm require a previous and next point to the actual point array.
    // Check if we will draw closed or open curve.
    // If closed, copy end points to beginning and first points to end
    // If open, duplicate first points to befinning, end points to end
    if (isClosed) {
        _pts.unshift(pts[pts.length - 1]);
        _pts.unshift(pts[pts.length - 2]);
        _pts.unshift(pts[pts.length - 1]);
        _pts.unshift(pts[pts.length - 2]);
        _pts.push(pts[0]);
        _pts.push(pts[1]);
    }
    else {
        _pts.unshift(pts[1]);   //copy 1. point and insert at beginning
        _pts.unshift(pts[0]);
        _pts.push(pts[pts.length - 2]); //copy last point and append
        _pts.push(pts[pts.length - 1]);
    }

    // ok, lets start..

    // 1. loop goes through point array
    // 2. loop goes through each segment between the 2 pts + 1e point before and after
    for (i=2; i < (_pts.length - 4); i+=2) {
        for (t=0; t <= numOfSegments; t++) {

            // calc tension vectors
            t1x = (_pts[i+2] - _pts[i-2]) * tension;
            t2x = (_pts[i+4] - _pts[i]) * tension;

            t1y = (_pts[i+3] - _pts[i-1]) * tension;
            t2y = (_pts[i+5] - _pts[i+1]) * tension;

            // calc step
            st = t / numOfSegments;

            // calc cardinals
            c1 =   2 * Math.pow(st, 3)  - 3 * Math.pow(st, 2) + 1;
            c2 = -(2 * Math.pow(st, 3)) + 3 * Math.pow(st, 2);
            c3 =       Math.pow(st, 3)  - 2 * Math.pow(st, 2) + st;
            c4 =       Math.pow(st, 3)  -     Math.pow(st, 2);

            // calc x and y cords with common control vectors
            x = c1 * _pts[i]    + c2 * _pts[i+2] + c3 * t1x + c4 * t2x;
            y = c1 * _pts[i+1]  + c2 * _pts[i+3] + c3 * t1y + c4 * t2y;

            //store points in array
            res.push(x);
            res.push(y);

        }
    }

    return res;
}







	</script>

</body>
</html>
